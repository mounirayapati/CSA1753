import heapq

# Goal state
GOAL = (1, 2, 3,
        4, 5, 6,
        7, 8, 0)

# Manhattan distance heuristic
def manhattan(state):
    dist = 0
    for i in range(9):
        if state[i] != 0:
            goal_pos = GOAL.index(state[i])
            dist += abs(i//3 - goal_pos//3) + abs(i%3 - goal_pos%3)
    return dist

# Get possible moves
def get_neighbors(state):
    neighbors = []
    zero = state.index(0)
    row, col = zero//3, zero%3
    moves = [(-1,0),(1,0),(0,-1),(0,1)]

    for dr, dc in moves:
        r, c = row + dr, col + dc
        if 0 <= r < 3 and 0 <= c < 3:
            new_zero = r*3 + c
            new_state = list(state)
            new_state[zero], new_state[new_zero] = new_state[new_zero], new_state[zero]
            neighbors.append(tuple(new_state))
    return neighbors

# A* Search
def solve(start):
    pq = []
    heapq.heappush(pq, (manhattan(start), 0, start, []))
    visited = set()

    while pq:
        f, g, state, path = heapq.heappop(pq)

        if state == GOAL:
            return path + [state]

        if state in visited:
            continue
        visited.add(state)

        for neighbor in get_neighbors(state):
            heapq.heappush(
                pq,
                (g + 1 + manhattan(neighbor), g + 1, neighbor, path + [state])
            )

    return None

# Input
start_state = (1, 2, 3,
               4, 0, 6,
               7, 5, 8)

solution = solve(start_state)

# Output
if solution:
    for step in solution:
        print(step[0:3])
        print(step[3:6])
        print(step[6:9])
        print("----")
else:
    print("No solution found")
